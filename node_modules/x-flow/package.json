{
  "name": "x-flow",
  "version": "2.2.0",
  "description": "x --> flow",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/miwoy/x-flow.git"
  },
  "keywords": [
    "flow",
    "waterfall",
    "async",
    "sync"
  ],
  "author": {
    "name": "miwoy"
  },
  "license": "ISC",
  "dependencies": {
    "underscore": "^1.8.3"
  },
  "readme": "# x-flow\nnode async x --> flow\n\n## 安装\n\n    npm install x-flow\n\n## 介绍\n\n  这是一个小型的异步流程控制工具，不同于Async的地方在于用的是链式调用，并且少了很多匿名的回调函数，看起来更简洁。\n\n  核心函数只有两个`fork()`与`next()`，`fork()`代表开始并行分支流，`next()`代表一个分支下的串行步骤，当然首先你需要用`begin()`函数返回一个`flow`对象。 并用`end()`函数结束`flow`.\n\n  此工具对异步函数有两个约定：\n\n  1. **异步函数必须存在`callback`,且是参数的最后一个位置,因为`flow`需要知道该异步函数在什么时候结束**\n  2. **回调函数参数必须存在`err`,且是参数第一个位置,因为`flow`通过检测回调的第一个参数判断是否出现异常**\n\n## 使用说明\n\n===========================***注意***================================\n\n* **x流执行数据结构是一个数组对象：`[context,func,args]`**\n\n* **其中如果`func`不依赖于一个执行环境可省略`context`或传入`this`或`null`**\n\n* **强烈建议不省略`context`**\n\n* **`args`参数不可省略!!!如异步函数不需要参数时传入`[]`或`null`**\n\n* **在`next`回调中当未返回或返回一个非数组或空数组时将跳过进入下一个有正确返回的`next`**\n* **若要中断流，可在`next`中返回第一个值为`true`的数组，该流将直接执行`end`例： `return [true, ...]`，数组从第二位开始可传递需要`end`接受的参数**\n\n==============================================================\n\n#### 并行与串行结合部分\n```` javascript\nvar x = require(\"x-flow\");\n \n/**\n *  测试并行与串行结合部分\n */\n\nvar obj = {\n\t// 定义一个有上下文的异步函数\n    asyncFunc: function(forkNum,funcNum,callback) {\n        setTimeout(function() {\n            console.log(\"第\" + forkNum + \"个分支的第\" +funcNum + \"异步函数开始执行\");\n            callback(null, \"第\" + forkNum + \"个分支的第\" +funcNum + \"异步函数执行结果\");\n        },100);\n    }\n};\n\n\n// 开始一个x流，可以为begin传递一个x流数据结构\nx.begin()\n\t// 指定异步函数执行上下文\n    .next(obj, obj.asyncFunc, [1,1])\n    // 用回调函数获取上一次异步结果，并返回一个x流执行数据结构的数组对象\n    .next(function(err, result) {\n    \tconsole.log(result);\n        return [obj, obj.asyncFunc, [1,2]];\n    })\n    // 开启一个分支。分支将与begin主线并行执行\n    .fork(obj, obj.asyncFunc, [2,1])\n    // 未获取上次异步函数执行结果，将会把结果传递至end函数results中\n    .next(obj, obj.asyncFunc, [2,2])\n    // 未获取上次异步执行结果，并未传递异步函数执行上下文\n    .next(obj.asyncFunc, [2,3])\n    /** \n     * x流结束，当流中某处出现错误时都将直接执行end方法\n     * 并将错误传给err参数\n     * results会把所有在流中未获取的返回值合并成数组 \n     * results: [[第一个分支（begin）所有未获取的返回值集合],[第二个分支（fork）所有未获取的返回值集合]...]\n     * 通常每个分支只有最后一个next的返回值未获取，那么当你取begin分支的结果事可能是这样的 results[0][0]\n     * results[0][0][0] 代表第一个分支第一个未获取的next返回值的非err的第一个参数\t\n     */\n    .end(function(err, results) {\n        console.log(\"end\", results);\n    });\n````\n-------------------\n#### each与eachSync部分\t\n```` javascript\n/**\n * 测试each与eachSync部分\n */\n\nvar obj = {\n    asyncFunc: function(value, index, callback) {\n        setTimeout(function() {\n            console.log(\"第\" + index + \"此执行\");\n            callback(null, value);\n        }, 100);\n    }\n};\n\n// 串行遍历\nx.eachSync([\"第一次返回\", \"第二次返回\", \"第三次返回\"], function(v, i) {\n    return [obj, obj.asyncFunc, [v, i]];\n}, function(err, results) {\n    console.log(\"result\", results);\n});\n\n// 并行遍历\nx.each([\"第一次返回\", \"第二次返回\", \"第三次返回\"], function(v, i) {\n    return [obj, obj.asyncFunc, [v, i]];\n}, function(err, results) {\n    console.log(\"result\", results);\n});\n````\n\n\n",
  "readmeFilename": "README.md",
  "gitHead": "a8aebe6da36cd2acff26ef2a0a1a0999d2f887e2",
  "bugs": {
    "url": "https://github.com/miwoy/x-flow/issues"
  },
  "homepage": "https://github.com/miwoy/x-flow#readme",
  "_id": "x-flow@2.2.0",
  "_shasum": "685e6477373af4f9c90cc7e350026ecb4371d18a",
  "_from": "x-flow@>=2.1.0 <3.0.0"
}
